#!/usr/bin/env python

## File: ToStatic.py
## Author: Yunqi Zhang
## Email: yunqi@umich.edu

import argparse
import json

import os.path

from collections import defaultdict

# Read a file line by line and return the content in a list
# @param filename The path to an existing file
# @return A list of lines in the specified file
def read_by_line(filename):
  content_list = []
  fp = open(filename)
  for line in fp:
    content_list.append(line)
  return content_list

# Parse a function in the asm file generated by verbose-asm
# @param asm_content The content of the asm file
# @param line_index The index of the first line of the function
# @return [line_index, func_name, inst_dict]
# @return line_index The index of the next line after the function
# @return func_name The name of the function parsed
# @return inst_dict The dictionary of the instructions in the function
def parse_asm_function(asm_content, line_index):
  i = line_index
  line = asm_content[line_index]
  items = line.strip().split()
  function_name = items[1]
  i = i + 3
  # Keep track of the instruction stream
  instruction_dict = {}
  instruction_index = 0
  # Loop through the lines
  while i < len(asm_content):
    line = asm_content[i].strip()
    # The end of the function
    if line.startswith(".size"):
      return [i + 1, function_name, instruction_dict]
    else:
      if not line.startswith("."):
        items = line.split()
        # Initialize the instruction's entry in the dict
        instruction_dict[instruction_index] = {}
        instruction_dict[instruction_index]["instruction"] = items[0]
        instruction_dict[instruction_index]["operand_0"] = None
        instruction_dict[instruction_index]["operand_1"] = None
        instruction_dict[instruction_index]["operand_2"] = None
        lookup = line.find("#")
        if lookup != -1:
          sub_str = line[lookup + 1:]
          sub_str = "".join(sub_str.split())
          sub_items = sub_str.split(",")
          if len(sub_items) >= 1:
            if sub_items[0] != "":
              instruction_dict[instruction_index]["operand_0"] = sub_items[0]
          if len(sub_items) >= 2:
            if sub_items[1] != "":
              instruction_dict[instruction_index]["operand_1"] = sub_items[1]
          if len(sub_items) >= 3:
            if sub_items[2] != "":
              instruction_dict[instruction_index]["operand_2"] = sub_items[2]
        instruction_index = instruction_index + 1
      i = i + 1

# Parse an asm file with verbose-asm
# @param asm_file The path to an existing asm file
# @return function_dict A dictionary to all the functions
def parse_asm(asm_file):
  function_dict = {}
  for f in asm_file:
    asm_content = read_by_line(f)
    i = 0
    while i < len(asm_content):
      line = asm_content[i]
      if line.startswith("\t.globl"):
        [line_index, function_name, inst_dict] = parse_asm_function(asm_content,
                                                                    i)
        #print(json.dumps([line_index, function_name, inst_dict], indent=2))
        function_dict[function_name] = inst_dict
        i = line_index
      else:
        i = i + 1
  #print(json.dumps(function_dict, indent=2))
  return function_dict

# Parse a function in the dump file generated by objdump
# @param dump_content The content of the dump file
# @param line_index The index of the first line of the function
# @return [line_index, func_name, addr_list]
# @return line_index The index of the next line after the function
# @return func_name The name of the function parsed
# @return addr_list The instruction addresses in list
def parse_dump_function(dump_content, line_index):
  i = line_index
  # Parse the function name first
  sub_str = dump_content[i]
  sub_str = sub_str[:-3]
  function_name = sub_str[sub_str.find("<") + 1:]
  i = i + 1
  addr_list = []
  # Loop through the function
  while i < len(dump_content):
    line = dump_content[i]
    if line == "\n":
      return [i + 1, function_name, addr_list]
    else:
      items = line.split("\t")
      if len(items) > 2:
        addr = items[0].strip()[:-1]
        addr_list.append(addr)
      i = i + 1
  # Return the same values if it is already EOF
  return [i, function_name, addr_list]

# Parse a dump file from objdump -d
# @param dump_file The path to an existing dump file
# @param function_dict A dictionay to all the functions
# @return function_dict A dictionay to all the functions
def parse_dump(dump_file, function_dict):
  dump_content = read_by_line(dump_file)
  i = 0
  # Loop through all the lines
  while i < len(dump_content):
    line = dump_content[i]
    if line.endswith(">:\n"):
      [line_index, func_name, addr_list] = parse_dump_function(dump_content,
                                                               i)
      i = line_index
      # Store the data back to function_dict
      if func_name in function_dict:
        #print(func_name)
        for j in range(len(function_dict[func_name])):
          function_dict[func_name][j]["addr"] = addr_list[j]
    else:
      i = i + 1
  return function_dict

# Parse a type section in the elf file
# @param elf_content The content of the elf file
# @param line_index The index of the first line of the type section
# @return [line_index, type_index, type_size]
# @return line_index The index of the next line after this type section
# @return type_index The index of the type in hex
# @return type_size The declaration size of the type
def parse_elf_type(elf_content, line_index):
  i = line_index
  index_str = elf_content[line_index]
  index_str = index_str[index_str.find(">") + 2:]
  index_str = index_str[:index_str.find(">")]
  type_index = index_str
  type_size = 1
  # If const
  if_const = False
  const_str = elf_content[line_index]
  if "const_type" in const_str:
    if_const = True
  else:
    if_const = False
  # If pointer
  if_pointer = False
  pointer_str = elf_content[line_index]
  if "pointer_type" in pointer_str:
    if_pointer = True
  else:
    if_pointer = False
  # If enum
  if_enum = False
  enum_str = elf_content[line_index]
  if "enumeration_type" in enum_str:
    if_enum = True
  else:
    if_enum = False
  i = i + 1
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(" <1>"):
      # The end of this type section
      return [i, type_index, type_size, if_const, if_pointer, if_enum]
    else:
      # type_size = upper_bound + 1
      if "DW_AT_upper_bound" in line and not if_enum:
        items = line.strip().split()
        size_str = items[len(items) - 1]
        if size_str.startswith("0x"):
          type_size = type_size * (int(size_str, 16) + 1)
        else:
          type_size = type_size * (int(size_str) + 1)
      i = i + 1

# Parse typedef in elf file
# @param elf_content The content of the elf file
# @param line_index The index of the first line of the typedef section
# @return [line_index, type_index, def_as]
# @return line_index The index of the next line after thie type section
# @return type_index The index of the type in hex
# @return def_as The index of the type that is being defined as
def parse_elf_typedef(elf_content, line_index):
  i = line_index
  index_str = elf_content[line_index]
  index_str = index_str[index_str.find(">") + 2:]
  index_str = index_str[:index_str.find(">")]
  type_index = index_str
  def_as = None
  i = i + 1
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(" <1>"):
      # The end of this typedef section
      return [i, type_index, def_as]
    else:
      if "DW_AT_type" in line:
        items = line.strip().split()
        def_as = items[len(items) - 1]
        def_as = def_as[def_as.find("x") + 1:def_as.find(">")]
      i = i + 1

# Parse a function section in the elf file
# @param elf_content The content of the elf file
# @param line_index The index of the first line of the function section
# @param type_dict The type dictionary
# @return [line_index, func_name, var_dict]
# @return line_index The index of the next line after this function section
# @return func_name The name of the function in this section
# @return var_dict A dictionary to all the variables in this function
def parse_elf_function(elf_content, line_index, type_dict):
  i = line_index
  term_str = elf_content[line_index]
  term_str = term_str[:term_str.find(">") + 1]
  func_if = False
  func_name = ""
  var_dict = {}
  i = i + 1
  # Initialize the low_pc and high_pc bound
  low_pc = None
  high_pc = None
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(term_str):
      # The last line of this section
      return [i, func_name, var_dict]
    elif line.endswith("block)\n"):
      # This is a block
      [line_index, v_dict] = parse_elf_block(elf_content,
                                             i, type_dict)
      for key, value in v_dict.items():
        var_dict[key] = value
      i = line_index
    elif line.endswith("variable)\n"):
      # This is a variable
      [line_index, var_name, v_dict] = parse_elf_variable(elf_content,
                                                          i, type_dict,
                                                          low_pc, high_pc)
      var_dict[var_name] = v_dict
      i = line_index
    elif line.endswith("parameter)\n"):
      # This is a parameter
      [line_index, var_name, v_dict] = parse_elf_variable(elf_content,
                                                          i, type_dict,
                                                          low_pc, high_pc)
      var_dict[var_name] = v_dict
      i = line_index
    else:
      if "DW_AT_name" in line and not func_if:
        # The name of the function
        items = line.strip().split()
        name_str = items[len(items) - 1]
        func_name = name_str
        func_if = True
      elif "DW_AT_low_pc" in line:
        # Update low_pc
        items = line.strip().split()
        pc_str = items[len(items) - 1]
        low_pc = pc_str
      elif "DW_AT_high_pc" in line:
        # Update high_pc
        items = line.strip().split()
        pc_str = items[len(items) - 1]
        high_pc = pc_str
      i = i + 1

# Parse a block section in the elf file
# @param elf_content The content of the elf file
# @param line_index The index of the first line of the block section
# @param type_dict The type dictionary
# @return [line_index, var_dict]
# @return line_index The index of the next line after this block section
# @return var_dict A dictionary to all the variables in this block
def parse_elf_block(elf_content, line_index, type_dict):
  i = line_index
  term_str = elf_content[line_index]
  term_str = term_str[:term_str.find(">") + 1]
  var_dict = {}
  i = i + 1
  low_pc = None
  high_pc = None
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(term_str):
      # The last line of this section
      return [i, var_dict]
    elif line.endswith("block)\n"):
      # This is a block (might happen recursively)
      [line_index, v_dict] = parse_elf_block(elf_content,
                                             i, type_dict)
      for key, value in v_dict.items():
        var_dict[key] = value
      i = line_index
    elif line.endswith("variable)\n"):
      # This is a variable
      [line_index, var_name, v_dict] = parse_elf_variable(elf_content,
                                                          i, type_dict,
                                                          low_pc, high_pc)
      var_dict[var_name] = v_dict
      i = line_index
    else:
      if "DW_AT_low_pc" in line:
        # Update low_pc
        items = line.strip().split()
        pc_str = items[len(items) - 1]
        low_pc = pc_str
      elif "DW_AT_high_pc" in line:
        # Update high_pc
        items = line.strip().split()
        pc_str = items[len(items) - 1]
        high_pc = pc_str
      i = i + 1

# Parse a variable section in the elf file
# @param elf_content The content of the elf file
# @param line_index The index of the first line of the block section
# @param type_dict The type dictionary
# @param low_pc The lower bound of the instruction address
# @param high_pc The upper bound of the instruction address
# @return [line_index, var_name, var_dict]
# @return line_index The index of the next line after this variable section
# @return var_name The name of the variable
# @return var_dict A dictionary to this variable
def parse_elf_variable(elf_content, line_index, type_dict, low_pc, high_pc):
  i = line_index
  term_str = elf_content[line_index]
  term_str = term_str[:term_str.find(">") + 1]
  var_name = ""
  var_dict = {
      "size": 1,
      "low_pc": low_pc,
      "high_pc": high_pc,
      "if_static": False,
      "if_const": False
      }
  i = i + 1
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(term_str):
      return [i, var_name, var_dict]
    else:
      if "DW_AT_name" in line:
        # The name of the variable
        items = line.strip().split()
        name_str = items[len(items) - 1]
        var_name = name_str
      elif "DW_AT_type" in line:
        # The type index of the variable
        items = line.strip().split()
        type_str = items[len(items) - 1]
        type_str = type_str[type_str.find("x") + 1:type_str.find(">")]
        # Look up the type_dict to get the size
        var_dict["size"] = type_dict[type_str]["size"]
        var_dict["if_const"] = type_dict[type_str]["if_const"]
        var_dict["if_pointer"] = type_dict[type_str]["if_pointer"]
        var_dict["if_enum"] = type_dict[type_str]["if_enum"]
      elif "DW_AT_location" in line:
        # Check if it is a static variable
        items = line.strip().split()
        static_str = items[len(items) - 1]
        static_str = static_str[:-1]
        if static_str.isdigit():
          static_addr = int(static_str, 16)
          if static_addr > 0:
            var_dict["if_static"] = True
      i = i + 1

# Parse the info dwarf section from readelf --debug-dump=info
# @param elf_file The path to an existing elf file
# @return variable_dict A dictionary to all the variables indexed by function
def parse_elf(elf_file):
  elf_content = read_by_line(elf_file)
  #print(elf_content)
  type_dict = {}
  # Initialize for the global variables
  variable_dict = {"GLOBAL":{}}
  # Parse types
  i = 0
  while i < len(elf_content):
    line = elf_content[i]
    if line.endswith("type)\n"):
      [line_index, type_index, type_size, if_const, if_pointer, if_enum] = \
          parse_elf_type(elf_content, i)
      type_dict[type_index] = {}
      type_dict[type_index]["size"] = type_size
      type_dict[type_index]["if_const"] = if_const
      type_dict[type_index]["if_pointer"] = if_pointer
      type_dict[type_index]["if_enum"] = if_enum
      i = line_index
    else:
      i = i + 1

  # Parse typedef
  i = 0
  while i < len(elf_content):
    line = elf_content[i]
    if line.endswith("typedef)\n"):
      [line_index, type_index, def_as] = \
          parse_elf_typedef(elf_content, i)
      if def_as is None:
        type_dict[type_index] = {
            "size": 1,
            "if_const": False,
            "if_pointer": False,
            "if_static": False,
            "if_enum": False
            }
      else:
        type_dict[type_index] = type_dict[def_as]
      i = line_index
    else:
      i = i + 1

  # Parse variables
  i = 0
  while i < len(elf_content):
    line = elf_content[i]
    if line.startswith(" <1>") and line.endswith("subprogram)\n"):
      # This is a function
      [line_index, func_name, var_dict] = parse_elf_function(elf_content,
                                                             i, type_dict)
      variable_dict[func_name] = var_dict
      i = line_index
    elif line.startswith(" <1>") and line.endswith("variable)\n"):
      # This is a variable
      [line_index, var_name, var_dict] = parse_elf_variable(elf_content,
                                                            i, type_dict,
                                                            None, None)
      variable_dict["GLOBAL"][var_name] = var_dict
      i = line_index
    else:
      i = i + 1
  return variable_dict

# Parse the function_dict and index the instructions by their addresses
# @param function_dict The original function dictionary
# @return instruction_dict A dictionary to all the instructions indexed by addr
def index_by_addr(function_dict):
  # Initialize the dictionary
  instruction_dict = {}
  for func, inst in function_dict.items():
    for index, detail in inst.items():
      dict_key = int(detail["addr"], 16)
      dict_value = {
          "function": func,
          "instruction": detail["instruction"],
          "operand_0": detail["operand_0"],
          "operand_1": detail["operand_1"],
          "operand_2": detail["operand_2"]
          }
      instruction_dict[dict_key] = dict_value
  return instruction_dict

def calculate_lifetime(variable_dict, instruction_dict):
  for func_name, variables in variable_dict.items():
    for var_name, var_dict in variables.items():
      if var_dict["low_pc"] is None and var_dict["high_pc"] is None:
        variable_dict[func_name][var_name]["lifetime"] = len(instruction_dict)
      else:
        low_pc = int(var_dict["low_pc"], 16)
        high_pc = low_pc + int(var_dict["high_pc"], 16)
        lifetime = 0
        for inst in instruction_dict.keys():
          if inst >= low_pc and inst <= high_pc:
            lifetime = lifetime + 1
        variable_dict[func_name][var_name]["lifetime"] = lifetime
  return variable_dict

# Parse the memory accesses profile
# @param acc_file The memory accesses profiling file
# @instruction_dict The dictionary to instructions
# @variable_dict The dictionary to variables
def parse_acc(acc_file, instruction_dict, variable_dict):
  acc_content = read_by_line(acc_file)
  tracking_dict = defaultdict(lambda: defaultdict(int))
  feature_list = []
  i = 0
  inst_count = 0
  while i < len(acc_content):
    line = acc_content[i]
    # R/W inst_addr mem_addr mem_dist branch_dist
    items = line.strip().split()
    inst_addr = int(items[1], 16)
    inst_count = inst_count + int(items[3])
    if inst_addr in instruction_dict:
      # addr, size, if_static, if_const, if_global, if_pointer, lifetime,
      # access_type, historical_percentage, mem_dist, branch_dist, reuse_dist
      temp_func_name = instruction_dict[inst_addr]["function"]
      temp_variable = None
      if instruction_dict[inst_addr]["operand_0"] is not None:
        temp_variable = instruction_dict[inst_addr]["operand_0"]
      elif instruction_dict[inst_addr]["operand_1"] is not None:
        temp_variable = instruction_dict[inst_addr]["operand_1"]
      else:
        temp_variable = instruction_dict[inst_addr]["operand_2"]
      if temp_variable is not None and \
          temp_variable in variable_dict[temp_func_name]:
        temp_percentage = 0.0
        if tracking_dict[items[2]]["total_access"] != 0:
          temp_percentage = float(tracking_dict[items[2]]["write_access"]) \
              / float(tracking_dict[items[2]]["total_access"])
        temp_reuse_dist = inst_count - tracking_dict[items[2]]["last_access"]
        temp_if_global = False
        if temp_func_name == "GLOBAL":
          temp_if_global = True
        temp_dict = variable_dict[temp_func_name][temp_variable]
        # ALl the interesting features
        local_addr = items[2]
        local_size = temp_dict["size"]
        local_if_static = temp_dict["if_static"]
        local_if_const = temp_dict["if_const"]
        local_if_global = temp_if_global
        local_if_pointer = temp_dict["if_pointer"]
        local_if_enum = temp_dict["if_enum"]
        local_lifetime = temp_dict["lifetime"]
        local_access_type = items[0]
        local_historical_percentage = temp_percentage
        local_mem_dist = int(items[3])
        local_branch_dist = int(items[4])
        local_reuse_dist = temp_reuse_dist
        local_dict = {
            "addr": local_addr,
            "size": local_size,
            "if_static": local_if_static,
            "if_const": local_if_const,
            "if_global": local_if_global,
            "if_pointer": local_if_pointer,
            "if_enum": local_if_enum,
            "lifetime": local_lifetime,
            "access_type": local_access_type,
            "historical_percentage": local_historical_percentage,
            "mem_dist": local_mem_dist,
            "branch_dist": local_branch_dist,
            "reuse_dist": local_reuse_dist,
            }
        feature_list.append(local_dict)
    # The total number of instructions so far
    tracking_dict[items[2]]["last_access"] = inst_count
    # Total number of accesses to the memory address
    tracking_dict[items[2]]["total_access"] = \
        tracking_dict[items[2]]["total_access"] + 1
    # Total number of accesses of write to the memory address
    if items[0] == "W":
      tracking_dict[items[2]]["write_access"] = \
          tracking_dict[items[2]]["write_access"] + 1
    i = i + 1
  # Calculate the overall write percentage
  i = 0
  for i in range(len(feature_list)):
    local_output = 0.0
    if tracking_dict[feature_list[i]["addr"]]["total_access"] != 0:
      local_output = \
          float(tracking_dict[feature_list[i]["addr"]]["write_access"]) \
          / float(tracking_dict[feature_list[i]["addr"]]["total_access"])
    feature_list[i]["output"] = local_output
  # Return the feature list
  return feature_list

# Main function
def main():
  # Parse the arguments
  parser = argparse.ArgumentParser()
  parser.add_argument("-a", "--access", required=True,
                      help="A file contains the profiled memory accesses")
  parser.add_argument("-s", "--asm", required=True, nargs="+",
                      help="A list of assembly files")
  parser.add_argument("-d", "--dump", required=True,
                      help="The output from objdump -d BINARY")
  parser.add_argument("-r", "--readelf", required=True,
                      help="The output from readelf --debug-dump=info BINARY")
  args = parser.parse_args()

  # Get the file names
  acc_file = args.access
  asm_file = args.asm
  dump_file = args.dump
  elf_file = args.readelf

  # Check whether these files exist
  for f in asm_file:
    if not os.path.isfile(f):
      print("[FATAL] File {0} does not exist.".format(f))
  if not os.path.isfile(acc_file):
    print("[FATAL] File {0} does not exist.".format(acc_file))
  elif not os.path.isfile(dump_file):
    print("[FATAL] File {0} does not exist.".format(dump_file))
  elif not os.path.isfile(elf_file):
    print("[FATAL] File {0} does not exist.".format(elf_file))

  function_dict = parse_asm(asm_file)
  function_dict = parse_dump(dump_file, function_dict)
  #print(json.dumps(function_dict, indent=2))
  variable_dict = parse_elf(elf_file)
  #print(json.dumps(variable_dict, indent=2))

  # Parse the function_dict and index instruction with addresses
  # All the indexing addresses are integers
  instruction_dict = index_by_addr(function_dict)
  #print(json.dumps(instruction_dict, indent=2))

  # Calculate the lifetime (#instructions) of each variable
  variable_dict = calculate_lifetime(variable_dict, instruction_dict)
  #print(json.dumps(variable_dict, indent=2))

  feature_list = parse_acc(acc_file, instruction_dict, variable_dict)

  # Print out the headers
  headers = "size,if_static,if_const,if_global,if_pointer,if_enum," \
      + "lifetime,access_type,historical_percentage_w,mem_dist,branch_dist," \
      + "reuse_dist,output"
  print(headers)
  # Print out the result
  for sample in feature_list:
    print("{0},{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11},{12}".format(
      sample["size"], sample["if_static"], sample["if_const"],
      sample["if_global"], sample["if_pointer"], sample["if_enum"],
      sample["lifetime"], sample["access_type"],
      sample["historical_percentage"], sample["mem_dist"],
      sample["branch_dist"], sample["reuse_dist"], sample["output"]))

if __name__ == "__main__":
  main()
